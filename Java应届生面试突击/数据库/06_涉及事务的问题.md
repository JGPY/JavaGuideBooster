# 涉及事务问题

### 目录

---
<a href="#1">1. 数据库事务正确执行的四个基本要素（事务的四个属性）。</a> <br>
<a href="#2">2. 并发事务带来的问题。</a> <br>
<a href="#3">3. 并发控制的方式（如何解决并发问题）。</a> <br>
<a href="#4">4. 数据库事物的隔离级别介绍、举例说明。</a> <br>
<a href="#5">5. MySQL事务控制语句。</a> <br>
<a href="#6">6. 数据库怎么保证数据的一致性。</a> <br>


### <a name="1">1. 数据库事务正确执行的四个基本要素（事务的四个属性）。</a>
&ensp;&ensp;&ensp;&ensp;
    事务是由一组 SQL 语句组成的逻辑处理单元。 <br>
&ensp;&ensp;&ensp;&ensp;
    *ACID:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、
持久性(Durability)*。 <br>
&ensp;&ensp;&ensp;&ensp;
    *原子性*:一个事务(transaction)中的所有操作,要么全部完成,要么全部不完成,
不会结束在中间某个环节。事务在执行过程中发生错误,会被 回滚 (Rollback)到事务开
始前的状态,就像这个事务从来没有执行过一样。 <br>
&ensp;&ensp;&ensp;&ensp;
    *一致性*:在事务开始和完成时,数据库中的数据都保持一致的状态,数据的*完整性约
束*没有被破坏。(事务的执行使得数据库*从一种正确状态*转换成*另一种正确状*)。具体
来说就是,比如表与表之间存在外键约束关系,那么你对数据库进行的修改操作就必需要
满足约束条件,即如果你修改了一张表中的数据,那你还需要修改与之存在外键约束关系
的其他表中对应的数据,以达到一致性。 <br>
&ensp;&ensp;&ensp;&ensp;
    *隔离性*:一个事务的执行不能被其他事务干扰。为了防止事务操作间的混淆,必须串
行化或序列化请求,使得在同一时间仅有一个请求用于同一数据。(*在事务正确提交之前*,
不允许把该事务*对数据的任何改变*提供给任何其他事务)。(事务处理过程中的中间状态
对外部是不可见的)。隔离性通过*锁*就可以实现。 <br>
&ensp;&ensp;&ensp;&ensp;
    *持久性*:一个事务一旦提交,它对数据库中数据的改变就应该是永久性的,并不会被
回滚。 <br>

### <a name="2">2. 并发事务带来的问题。</a>
1. 更新丢失。 <br>
&ensp;&ensp;&ensp;&ensp;
    两个事务 Tl 和 T2 读入同一数据并修改,T2 提交的结果覆盖了 Tl 提交
的结果,导致 Tl 的修改被丢失。
2. 脏读。 <br>
&ensp;&ensp;&ensp;&ensp;
    事务 Tl 修改某一数据,并将其写回磁盘,事务 T2 读取同一数据后,Tl 由
于某种原因被撤销,这时 Tl 已修改过的数据恢复原值,T2 读到的数据就与数
据库中的数据不一致,则 T2 读到的数据就为“脏”数据,即不正确的数据。 <br>
*例如:* <br>
&ensp;&ensp;&ensp;&ensp;
    张三的工资为 5000,事务 A 中把他的工资改为 8000,但事务 A 尚未提交。
与此同时,事务 B 正在读取张三的工资,读取到张三的工资为 8000。随后,
事务 A 发生异常,而回滚了事务。张三的工资又回滚为 5000。最后,事务 B 读
取到的张三工资为 8000 的数据即为脏数据,事务 B 做了一次脏读。
3. 不可重复读。 <br>
&ensp;&ensp;&ensp;&ensp;
    是指在一个事务内,多次读同一数据。在这个事务还没有结束时,另外一
个事务也访问该同一数据。那么,在第一个事务中的两次读数据之间,由于第
二个事务的修改,那么第一个事务两次读到的的数据可能是不一样的。这样就
发生了*在一个事务内两次相同的查询*读到的数据是不一样的,因此称为是不可
重复读。 <br>
*例如:* <br>
&ensp;&ensp;&ensp;&ensp;
    在事务 A 中,读取到张三的工资为 5000,操作没有完成,事务还没提交。
与此同时,事务 B 把张三的工资改为 8000,并提交了事务。随后,在事务 A 中,
再次读取张三的工资,此时工资变为 8000。在一个事务中前后两次读取的结果
并不致,导致了不可重复读。
4. 幻读。 <br>
*例如:* <br>
&ensp;&ensp;&ensp;&ensp;
    目前工资为 5000 的员工有 10 人,事务 A 读取所有工资为 5000 的人数为
10 人。此时,事务 B 插入一条工资也为 5000 的记录。这是,事务 A 再次读取
工资为 5000 的员工,记录为 11 人。此时产生了幻读。

*不可重复读的重点是修改:* <br>
同样的条件,你读取过的数据,再次读取出来发现值不一样了。 <br>
*幻读的重点在于新增或者删除:* <br>
同样的条件,第 1 次和第 2 次读出来的*记录数不一样*。 <br>

避免不一致性的方法和技术就是并发控制。最常用的技术是*封锁技术*。

### <a name="3">3. 并发控制的方式（如何解决并发问题）。</a>
&ensp;&ensp;&ensp;&ensp;
    加锁,如乐观锁和悲观锁。
    
### <a name="4">4. 数据库事物的隔离级别介绍、举例说明。</a>
&ensp;&ensp;&ensp;&ensp;
    数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们
不会相互影响, *避免各种并发问题*。
#### 数据库提供了 4 种隔离级别(由低到高):
这 4 个级别可逐个解决脏读,不可重复读和幻读这几个问题。
1. 读未提交数据 <br>
&ensp;&ensp;&ensp;&ensp;
    允许事务读取*未被其他事务提交的变更*,可能有*脏读, 不可重复读和幻读*的问题。
&ensp;&ensp;&ensp;&ensp;
    比如:某时刻会话 a 修改了一个数据,但还未提交,此时会话 b 读取了该数据,这是,
会话 a 回滚了事务,这就导致数据出现了不一致状态,这就是*脏读*。
2. 读已提交数据 <br>
&ensp;&ensp;&ensp;&ensp;
    允许事务读取*已经被其他事务提交的变更*,可以*避免脏读*,*可能有不可重复读和幻读*
的问题。 <br>
&ensp;&ensp;&ensp;&ensp;
    例如:某时刻会话 a 的一个事务里查询一个数据,得到的数据是 1,这时*会话 b 修改
了该数据的值为 2,并提交了*, 此时会话 a 的事务又要读取该数据,这时的数据是 2,就样
就出现了*同一个事务内,读的结果不一样,这就是不可重复读*。 <br>
&ensp;&ensp;&ensp;&ensp;
    *不可重复读*,是指在数据库访问中,*一个事务范围内两个相同的查询却返回了不同数
据*。
3. 可重复读(Mysql 的默认隔离级别) <br>
&ensp;&ensp;&ensp;&ensp;
    确保事务*可以多次从一个字段中读取相同的值*,在这个事务持续期间,禁止其他事务
对这个字段进行更新,可以*避免脏读和不可重复读,可能会有幻读*。
4. 可串行化 <br>
&ensp;&ensp;&ensp;&ensp;
    所有事务都一个接一个地*串行执行*。可以避免*脏读,不可重复读,幻读*。 <br>
![06_4_1](/data/images/Java应届生面试突击/数据库/06_4_1.png) <br>

### <a name="5">5. MySQL事务控制语句。</a>
&ensp;&ensp;&ensp;&ensp;
    *BEGIN 或 START TRANSACTION:*显示地开启一个事务;
&ensp;&ensp;&ensp;&ensp;
    COMMIT:提交事务,并使已对数据库进行的所有修改称为永久性的;
&ensp;&ensp;&ensp;&ensp;
    ROLLBACK:回滚会结束用户的事务,并撤销正在进行的所有未提交的修改;
    
### <a name="16">6. 数据库怎么保证数据的一致性。</a>
&ensp;&ensp;&ensp;&ensp;
    事务,悲观锁,乐观锁。
---
### 搬运工信息
Author:Jason Lou <br>
Email:vip.iotworld@gmail.com <br>
Blog:https://blog.csdn.net/qq_21508727 <br>
Github:https://github.com/JGPY/JavaGuideBooster <br>
---