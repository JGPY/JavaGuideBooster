# 其他相关的问题
### 目录

---
<a href="#1">1. Session 原理。</a> <br>
<a href="#2">2. Cookie 的机制。</a> <br>
<a href="#3">3. Cookie 被浏览器禁用怎么办?</a> <br>
<a href="#4">4. Cookie 和 Session 原理解析。</a> <br>
<a href="#5">5. Cookie 与 Session 的区别。</a> <br>
<a href="#6">6. session 和 cache 的区别。</a> <br>
<a href="#7">7. 如果有几千个 session,怎么提高效率 。当 session 访问量比较大的时候,怎么解决?</a> <br>
<a href="#8">8. 在浏览器中输入 URL 后,执行的全部过程。会用到哪些协议?(一次完整的 http 请求过程)。</a> <br>
<a href="#9">9. 路由器与交换机的区别是什么?</a> <br>

### <a name="1">1. Session 的原理。</a>

#### Session 存储方式:
&ensp;&ensp;&ensp;&ensp;
    session 可以放在文件、内存中或数据库都可以,是以键值对的形式存储。Session
也是一种 key-value 的属性对。
&ensp;&ensp;&ensp;&ensp;    
    当程序需要为某个客户端的请求创建一个 session 的时候,服务器首先检查这个客户
端的请求里是否已包含了一个 session 标识 - 称为 session id,如果已包含一个 session id
则说明以前已经为此客户端创建过 session,服务器就按照 session id 把这个 session 检索
出来使用(如果检索不到,可能会新建一个,根据 getSession()方法的参数),如果客户
端请求不包含 session id,则为此客户端创建一个 session 并且生成一个与此 session 相关
联的 session id,这个 session id 将被在本次响应中返回给客户端保存。
Session 的客户端实现形式(即 Session ID 的保存方法)
一般浏览器提供了 3 种方式来保存:
[1] 使用 Cookie 来保存,这是最常见的方法,“记住我的登录状态”功能的实现正是基
于这种方式的。服务器通过设置 Cookie 的方式将 Session ID 发送到浏览器。如果我们不
设置过期时间,那么这个 Cookie 将不存放在硬盘上,当浏览器关闭的时候,Cookie 就消
失了,这个 Session ID 就丢失了。如果我们设置这个时间,那么这个 Cookie 会保存在客
户端硬盘中,即使浏览器关闭,这个值仍然存在,下次访问相应网站时,同 样会发送到服
务器上。
[2] URL 重写,就是把 session id 直接附加在 URL 路径的后面,也就是像我们经常看到
JSP 网站会有 aaa.jsp?JSESSIONID=*一样的。
[3] 在页面表单里面增加隐藏域,这种方式实际上和第二种方式一样,只不过前者通过
GET 方式发送数据,后者使用 POST 方式发送数据。但是明显后者比较麻烦。
就是服务器会自动修改表单,添加一个隐藏字段,以便在表单提交时能够把 session id
传递回服务器。比如:
```html
<form name="testform" action="/xxx">
    <input type="hidden" name="jsessionid"
    value="ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764">
    <input type="text">
</form>
```

#### session 什么时候被创建?
一个常见的错误是以为 session 在有客户端访问时就被创建,然而事实是直到某 server
端程序(如 Servlet)调用 HttpServletRequest.getSession(true)这样的语句时才会被创建。

#### session 何时被删除?
session 在下列情况下被删除:
A.程序调用 HttpSession.invalidate()
B.距离上一次收到客户端发送的 session id 时间间隔超过了 session 的最大有效时间
C.服务器进程被停止
再次注意关闭浏览器只会使存储在客户端浏览器内存中的 session cookie 失效,不会
使服务器端的 session 对象失效。
getSession()/getSession(true)、getSession(false)的区别
getSession()/getSession(true):当 session 存在时返回该 session,否则新建一个
session 并返回该对象。
getSession(false):当 session 存在时返回该 session,否则不会新建 session,返回
null。


### <a name="2">2. Cookie 的机制。</a>

#### Cookie 存储方式:
1.以文件方式存在硬盘空间上的永久性的 cookie。持久 cookie 是指存放于客户端硬盘
中的 cookie 信息(设置了一定的有效期限),当用户访问某网站时,浏览器就会在本地
硬盘上查找与该网站相关联的 cookie。如果该 cookie 存在,浏览器就将它与页面请求一
起通过 HTTP 报头信息发送到您的站点,然后在系统会比对 cookie 中各属性和值是否与
存放在服务器端的信息一致,并根据比对结果确定用户为“初访者”或者“老客户”。
2.停留在浏览器所占内存中的临时性的 cookie,关闭 Internet Explorer 时即从计算机
上删除。

#### Cookie 的有效期:
Cookie 的 maxAge 决定着 Cookie 的有效期,单位为秒。
如果 maxAge 属性为正数,则表示该 Cookie 会在 maxAge 秒之后自动失效。浏览器会将
maxAge 为正数的 Cookie 持久化,即写到对应的 Cookie 文件中。无论客户关闭了浏览器
还是电脑,只要还在 maxAge 秒之前,登录网站时该 Cookie 仍然有效。下面代码中的 Cookie
信息将永远有效。
```java
Cookie cookie = new Cookie("username","helloweenvsfei"); // 新建 Cookie
cookie.setMaxAge(Integer.MAX_VALUE);            // 设置生命周期为 MAX_VALUE
response.addCookie(cookie);                // 输出到客户端
```

如果 maxAge 为负数,则表示该 Cookie 仅在本浏览器窗口以及本窗口打开的子窗口内有
效,关闭窗口后该 Cookie 即失效。 maxAge 为负数的 Cookie,为临时性 Cookie, Cookie
信息保存在浏览器内存中,因此关闭浏览器该 Cookie 就消失了。Cookie 默认的 maxAge
值为–1。
如果 maxAge 为 0,则表示删除该 Cookie。Cookie 机制没有提供删除 Cookie 的方法,
因此通过设置该 Cookie 即时失效实现删除 Cookie 的效果。失效的 Cookie 会被浏览器从
Cookie 文件或者内存中删除,
例如:
```java
Cookie cookie = new Cookie("username","helloweenvsfei");// 新建 Cookie
cookie.setMaxAge(0); // 设置生命周期为 0,表示删除该 cookie
response.addCookie(cookie); // 必须执行这一句
```


#### Cookie 的组成部分。
Cookie 在 HTTP 的头部信息中。
标 准 格 式 : Set - Cookie: NAME=VALUE ; Expires=DATE ; Path=PATH ;
Domain=DOMAIN_NAME;SECURE;
举例说明:Set-Cookie: JSESSIONID=mysession; Expires=Thu, 05-Jun-2
008 05:02:50 GMT; Path=/web;
Cookie 的内容主要包括:名字,值,过期时间,域和路径。
Cookie 的 Expires 属性标识了 Cookie 的有效时间,当 Cookie 的有效时间过了之后,
这些数据就被自动删除了。若不设置过期时间,则表示这个 cookie 的生命期为浏览器会话
期间,关闭浏览器窗口,cookie 就消失。这种生命期为浏览器会话期的 cookie 被称为会
话 cookie(临时性 cookie),会话 cookie 保存在内存里。若设置了过期时间,浏览器
就会把 cookie 保存到硬盘上,关闭后再次打开浏览器,这些 cookie 仍然有效直到超过设
定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享,比如两个 IE
窗口。
Cookie 的域和路径属性一起构成 cookie 的作用范围。
domain 属性可以使多个 web 服务器共享 cookie。
path 指定与 cookie 关联在一起的网页。

### <a name="3">3. Cookie 被浏览器禁用怎么办?</a>
cookie 可以被人为的禁止,则必须有其他机制以便在 cookie 被禁止时仍然能够把
session id 传递回服务器。
[1] URL 重写,就是把 session id 直接附加在 URL 路径的后面,也就是像我们经常看到
JSP 网站会有 aaa.jsp?JSESSIONID=*一样的。
[2] 在页面表单里面增加隐藏域,这种方式实际上和第 1 种方式一样,只不过前者通过
GET 方式发送数据,后者使用 POST 方式发送数据。但是明显后者比较麻烦。
就是服务器会自动修改表单,添加一个隐藏字段,以便在表单提交时能够把 session id
传递回服务器。比如:
```html
<form name="testform" action="/xxx">
    <input type="hidden" name="jsessionid"
        value="ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764">
    <input type="text">
</form>
```


### <a name="4">4. Cookie 和 Session 原理解析。</a>
客户第一次发送请求给服务器,此时服务器产生一个唯一的 sessionID,并返回给客户
端(通过 cookie),此时的 cookie 并没有 setMaxAge();只是保存于客户端的内存中,并与一
个浏览器窗口对应着,由于 HTTP 协议的特性,这一次连接就断开了。以后此客户端再发送
请求给服务器的时候,就会在请求 request 中携带 cookie,由于 cookie 中有 sessionID,所以
服务器就知道这是刚才那个客户,从而区分不同的人,购物车就是这样实现的。

第一次请求时:(注意,访问 jsp 时会自动创建 sessionID,而访问 Servlet,需要你自己写代
码才会创建 sessionID)


### <a name="5">5. Cookie 与 Session 的区别。</a>
1、cookie 数据存放在客户端,用来记录用户信息的,session 数据放在服务器上。
2、正是由于 Cookie 存储在客户端中,对客户端是可见的,客户端的一些程序可能会窥探、
复制甚至修改 Cookie 中的内容。而 Session 存储在服务器上,对客户端是透明的,不存在
敏感信息泄露的危险。
如果选用 Cookie,比较好的办法是,敏感的信息如账号密码等尽量不要写到 Cookie
中。最好是像 Google、Baidu 那样将 Cookie 信息加密,提交到服务器后再进行解密,保
证 Cookie 中的信息只有自己能读得懂。而如果选择 Session 就省事多了,反正是放在服务
器上,Session 里任何隐私都可以。
3、Session 是保存在服务器端的,每个用户都会产生一个 Session。如果并发访问的用户
非常多,会产生非常多的 Session,消耗大量的服务器内存。因此像 Google、Baidu、Sina
这样并发访问量极高的网站,是不太可能使用 Session 来追踪客户会话的。
而 Cookie 保存在客户端,不占用服务器资源。如果并发浏览的用户非常多,Cookie
是很好的选择。对于 Google、Baidu、Sina 来说,Cookie 也许是唯一的选择。
4、cookie 的容量和个数都有限制。单个 cookie 的容量不能超过 4KB,很多浏览器都限制
一个站点最多保存 20 个 cookie,而 session 没有此问题。
5、所以个人建议:
将登录信息等重要信息存放到 SESSION 中,其他信息如果需要保留,可以放在
COOKIE 中。

### <a name="6">6. session 和 cache 的区别。</a>
&ensp;&ensp;&ensp;&ensp;
    Session 是单用户的会话状态。当用户访问网站时,产生一个 SESSIONID。并存在
于 COOKIES 中。每次向服务器请求时,发送这个 COOKIES ,再从服务器中检索是否
有这个 SESSIONID 保存的数据。而 cache 则是服务器端的缓存,是所有用户都可以访问
和共享的。因为从 Cache 中读数据比较快,所以有些系统(网站)会把一些经常被使用的
数据放到 Cache 里,提高访问速度,优化系统性能。

### <a name="7">7. 如果有几千个 session,怎么提高效率 。当 session 访问量比较大的时候,怎么解决?</a>
把 session 放到 redis 或 memcache 等此类内存缓存中或着把 session 存储在 SSD硬盘上。


### <a name="8">8. 在浏览器中输入 URL 后,执行的全部过程。会用到哪些协议?(一次完整的 http 请求过程)。</a>

#### 一.域名解析

比如要查询 www.baidu.com 的 IP 地址:
1.浏览器搜索自己的 DNS 缓存(维护一张域名与 IP 地址的对应表);
2.若没有,则搜索操作系统中的 DNS 缓存(维护一张域名与 IP 地址的对应表);
3.若没有,则搜索操作系统的 hosts 文件( Windows 环境下,维护一张域名与 IP 地址的
对应表);
4.若没有,则操作系统将域名发送至 本地域名服务器--(递归查询方式),本地域名服务
器 查询自己的 DNS 缓存,查找成功则返回结果,否则,(以下是迭代查询方式)
4.1.本地域名服务器 向根域名服务器(其虽然没有每个域名的的具体信息,但存储了负
责每个域,如 com、net、org 等的解析的顶级域名服务器的地址)发起请求,此处,根域
名服务器返回 com 域的顶级域名服务器的地址;
4.2.本地域名服务器 向 com 域的顶级域名服务器发起请求,返回 baidu.com 权限域名
服务器(权限域名服务器,用来保存该区中的所有主机域名到 IP 地址的映射)地址;
4.3.本地域名服务器 向 baidu.com 权限域名服务器发起请求,得到 www.baidu.com 的
IP 地址;
5.本地域名服务器 将得到的 IP 地址返回给操作系统,同时自己也将 IP 地址缓存起来;
6.操作系统将 IP 地址返回给浏览器,同时自己也将 IP 地址缓存起来;
7.至此,浏览器已经得到了域名对应的 IP 地址。

#### 二.三次握手

详细过程见前面的内容。
#### 三. ARP(地址解析协议)
ARP 解决的是同一个局域网内,主机或路由器的 IP 地址和 MAC 地址的映射问题。如果
源主机和目的主机在同一个局域网内(目标 IP 和本机 IP 分别与子网掩码相与的结果相同,
那么它们在一个子网),就可以用 ARP 找到目的主机的 MAC 地址;如果不在一个局域网内,
用 ARP 协议找到本网络内的一个路由器的 MAC 地址,剩下的工作由这个路由器来完成。
ARP 协议的具体内容是:
01 每个主机都会有 ARP 高速缓存,存储本局域网内 IP 地址和 MAC 地址之间的对应关系。
02 当源主机要发送数据时,首先检查 ARP 高速缓存中是否有对应 IP 地址的目的主机的
MAC 地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送 ARP 请求分
组,该数据包包括的内容有:(源主机 IP 地址,源主机 MAC 地址,目的主机的 IP 地址)。
03 当本网络的所有主机收到该 ARP 请求分组时,首先检查数据包中的 IP 地址是否是自
己的 IP 地址,如果不是,则忽略该数据包;如果是,则首先从数据包中取出源主机的 IP 地
址和 MAC 地址写入到 ARP 高速缓存中,如果已经存在,则覆盖,然后将自己的 MAC 地址
写入 ARP 响应包中,告诉源主机自己是它想要找的 MAC 地址。
04 源主机收到 ARP 响应分组后,将目的主机的 IP 和 MAC 地址写入 ARP 高速缓存中,
并利用此信息发送数据。如果源主机一直没有收到 ARP 响应分组,表示 ARP 查询失败。

#### 四.路由选择协议
网络层主要做的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,
这些都是由路由器来完成的工作,通过查找路由表决定通过那个路径到达服务器,其中用到
路由选择协议。
有两大类路由选择协议:(有时间补上算法的具体内容!!!)
1.内部网关协议
内 部网 关协 议 IGP(Interior Gateway Protocol)即在 一 个 自治 系 统 内 部 使 用的 路由 选择 协
议,RIP 和 OSPF 协议和 IS-IS 协议,IGRP(内部网关路由协议)、EIGRP(增强型内部网关路
由协议)。
1)RIP(应用层协议,基于 UDP)
RIP 是一种基于距离向量的路由选择协议。 RIP 协议要求网络中的每一个路由器都要维
护从它自己到其他每一个目的网络的距离记录。这里的“距离”实际上指的是“最短距离”。
RIP 认为一个好的路由就是它通过的路由器的数目少,即“距离短”。RIP 允许一条路径最
多只能包含 15 个路由器。“距离”的最大值为 16 时即相当于不可达。RIP 选择一个具有最
少路由器的路由(即最短路由),哪怕还存在另一条高速(低时延)但路由器较多的路由。
2)OSPF(网络层协议)
“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法。使用 洪泛法向本自治系
统中所有路由器发送信息。发送的信息就是与本路由器相邻的所有路由器的链路状态(“链
路状态”就是说明本路由器都和哪些路由器相邻,以及该链路的“度量”),但这只是路由器
所知道的部分信息。只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此
信息。
2.外部网关协议
1)BGP 协议(应用层协议,基于 TCP 的)
BGP 是不同自治系统的路由器之间交换路由信息的协议。边界网关协议 BGP 只能是力
求寻找一条能够到达目的网络且比较好的路由(不能兜圈子),而并非要寻找一条最佳路
由。
BGP 发言人:每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP
发言人”。一般说来,两个 BGP 发言人都是通过一个共享网络连接在一起的,而 BGP 发言
人往往就是 BGP 边界路由器,但也可以不是 BGP 边界路由器。
BGP 交换路由信息:
一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息,就要先建立 TCP 连
接,然后在此连接上交换 BGP 报文以建立 BGP 会话(session),利用 BGP 会话交换路由信息。
使用 TCP 连接能提供可靠的服务也简化了路由选择协议。使用 TCP 连接交换路由信息的两
个 BGP 发言人,彼此成为对方的邻站或对等站。BGP 所交换的路由信息就是到达某个网络
所要经过的一系列 AS。

1)首先从 IP 数据报首部提取出目的主机的 IP 地址 D,得出其所在的网络 N。
(2)若 N 就是与此路由器直接相连的某个网络,则进行直接交付,直接把数据报交付给目
的主机。否则就执行(3)。
(3)若路由表中有目的地址为 D 的特定主机路由,则把数据报传给路由表中所指明的下一
跳路由器。否则执行(4)。
(4)若路由表中有到达网络 N 的路由,则把数据报传给路由表中所指明的下一跳路由器。
否则执行(5)。
(5)若路由表中有一个默认路由,则把数据报传给默认路由所指明的默认路由器。否则执
行(6)。
(6)报告转发分组出错。

#### 五.建立 TCP 连接后发起 http 请求
说下 HTTP 的浏览器缓存机制。POST 还是 GET。

#### 六.服务器收到请求并响应 http 请求
1.负载均衡
网站可能会有负载均衡设备来平均分配所有用户的请求。即对工作任务进行平衡,分
摊到多个操作单元上执行,如图片服务器,应用服务器等。
2.请求处理阅读请求及它的参数和 cookies。

#### 七.浏览器解析 html 代码,并请求 html 代码中的资源(如 js、css、
     图片等)
看是否是长连接。来决定是不是断开 TCP 连接。
#### 八.断开 TCP 连接

#### 九. 浏览器对页面进行渲染呈现给用户

### <a name="9">9. 路由器与交换机的区别是什么?</a>
1.交换机工作在数据链路层;路由器工作在网络层。
2.交换机转发数据帧;路由器转发 IP 分组。
3.交换机隔离冲突域,不隔离广播域;路由器隔离冲突域,隔离广播域


---
### 搬运工信息
Author:Jason Lou <br>
Email:vip.iotworld@gmail.com <br>
Blog:https://blog.csdn.net/qq_21508727 <br>
Github:https://github.com/JGPY/JavaGuideBooster <br>
---
